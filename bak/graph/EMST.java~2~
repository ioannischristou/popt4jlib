package graph;

import java.util.*;
import utils.*;

/**
 * Minimum Spanning Tree.
 * Kruskal's Algorithm Implementation.
 * <p>Title: Coarsen-Down/Cluster-Up</p>
 * <p>Description: Hyper-Media Clustering System</p>
 * <p>Copyright: Copyright (c) 2005</p>
 * <p>Company: AIT</p>
 * @author Ioannis T. Christou
 * @version 1.0
 */
public class EMST {
  private Graph _g;  // the graph for which we want a Minimum Spanning Tree

  public EMST(Graph g) throws GraphException {
    _g = g;
  }


  /**
   * Kruskal's algorithm for computing the MST of the graph _g.
   * Uses the DisjointSet data structure for high performance
   * @return double
   */
  public double cost() {
    double res = 0.0;
    DisjointSet djset = new DisjointSet();
    // 1. put every node in its own set
    for (int i=0; i<_g.getNumNodes(); i++) {
      djset.makeSet(_g.getNode(i));
    }
    // 2. sort the links in asc. order
    Link[] links = new Link[_g.getNumArcs()];
    for (int i=0; i<links.length; i++) {
      links[i] = _g.getLink(i);
    }
    Arrays.sort(links, new LinkComp());
    // 3. for each link in the sorted links array check if both ends of the link
    //    are in the same set. If not, add link to the mst, and unite two sets,
    //    else discard link
    for (int i=0; i<links.length; i++) {
      DisjointSetElem start = djset.find(_g.getNode(links[i].getStart()));
      DisjointSetElem end = djset.find(_g.getNode(links[i].getEnd()));
      if (start != end) {
        djset.union(start, end);
        res += links[i].getWeight();
      }
      // else no-op
    }
    return res;
  }
}


class LinkComp implements Comparator, java.io.Serializable {
  public int compare(Object x, Object y) {
    Link xp = (Link) x;
    Link yp = (Link) y;
    double xv = xp.getWeight();
    double yv = yp.getWeight();
    if (xv < yv)return -1;
    else if (xv > yv)return 1;
    return 0;
  }
}

